\pgfdeclarelayer{pre main}
\pgfdeclarelayer{background}
\pgfdeclarelayer{foreground}
\pgfsetlayers{background,pre main,main,foreground} 
% Декорация линий
\tikzset{
	% стрелки
	FARROW/.style={
%		line width=3mm, 
%		arrows={-Latex[angle=40:2.5mm]}
		arrows={-Straight Barb[angle=45:1.5mm 1]	},
		shorten >= 0pt,
	},
	% декорация линий
	curve line/.style={
		decoration={
			snake,
			amplitude=1.5mm,%0.75mm,
			segment length=7.5mm,
			post length=0mm,
			pre length=0mm,
		},
	},
	pointnode/.style={
		join=by -,
		circle,
		fill=red,
		minimum size=3pt,
		inner sep=0pt,
	},
	circlenode/.style={
		draw,thick,fill=blue!10,line width=0.25mm,
		shape=circle,
		inner sep=4pt,
	},
	rectnode/.style={
		draw,line width=0.25mm,
		shape=rectangle,
%		rounded corners=2pt, 
		inner sep=8pt,
	},
	rrectnode/.style={
		draw,line width=0.25mm,
		shape=rounded rectangle,
%		rounded corners=2pt, 
		inner sep=8pt,
	},
	datanode/.style={
		draw,line width=0.25mm,
		shape=	trapezium,
		trapezium left angle=70,
		trapezium right angle=110, 
		text centered,
		inner sep=8pt,
	},
	ifthenelsenode/.style={
		draw,line width=0.25mm,
		shape=diamond,
		aspect=2,
%		trapezium left angle=70,
%		trapezium right angle=110, 
		text centered,
		inner sep=4pt,
	},
	startloopnode/.style={
		draw,text width=4cm,align=center,line width=0.25mm,
		shape=chamfered rectangle,
		chamfered rectangle corners={north west,north east},
		minimum height=3em,minimum width=5cm,
	},
	endloopnode/.style={
		draw,text width=4cm,align=center,line width=0.25mm,
		shape=chamfered rectangle,
		chamfered rectangle corners={south west,south east},
		minimum height=3em,minimum width=5cm,
	},
	signalnode/.style={
		draw,line width=0.25mm,
		shape=chamfered rectangle,
		chamfered rectangle angle=45,
		chamfered rectangle xsep=1cm,
		inner sep=8pt,
	},
}

\newpage

\section{Методы локальной оптимизации}

Оптимизация -- это задача нахождения экстремума 
(минимума или максимума) целевой функции в некоторой области 
конечномерного векторного пространства, ограниченной 
набором линейных и/или нелинейных равенств и/или неравенств.

Во многих практически важных случаях для целевой функции 
многих переменных $f(\vect{x})$ 
задача оптимизации может быть сформулирована в виде:
\begin{gather*}
f(\vect{x})\to\min,
\end{gather*}
где $\vect{x}=(x_1,x_2,\ldots,x_n)$ --
вектор неизвестных (управляющих параметров);\linebreak
$\min$ -- минимальное значение функции в ограниченной 
или неограниченной области изменения неизвестных.

Для нахождения абсолютного минимума целевой функции $f(\vect{x})$
существует только один способ: 
найти все локальные минимумы этой функции, 
сравнить их и выбрать из них тот,
в котором функция принимает наименьшее значение.

% Минимум функции одного переменного 
% http://www.machinelearning.ru/wiki/index.php?title=%D0%9C%D0%B5%D1%82%D0%BE%D0%B4_%D0%B7%D0%BE%D0%BB%D0%BE%D1%82%D0%BE%D0%B3%D0%BE_%D1%81%D0%B5%D1%87%D0%B5%D0%BD%D0%B8%D1%8F._%D0%A1%D0%B8%D0%BC%D0%BC%D0%B5%D1%82%D1%80%D0%B8%D1%87%D0%BD%D1%8B%D0%B5_%D0%BC%D0%B5%D1%82%D0%BE%D0%B4%D1%8B
\emptyline
\subsection{Минимум функции одного переменного}
Для функции одной переменной $f(x)$, задача нахождения минимума
эквивалента задачи нахождения корней уравнения:
\begin{equation}\label{eq:GD:f(x)=min}
\diff{f(x)}{x}=0
\end{equation}

Эта одномерная задача нередко возникает в практических 
приложениях. Кроме того, большинство методов решения 
многомерных задач сводится к поиску одномерного минимума. 

Предположим, что $f(x)$ задана и кусочно-непрерывна на отрезке 
$x\in[a,b]$, и имеет на этом отрезке (включая его концы) 
только один локальный минимум. 
Построим итерационный процесс, сходящийся к этому минимуму. 

Вычислим значение функции на концах отрезка $x=a$ и $x=b$, 
а также в двух внутренних точках $x_1<x_2$.
Так так функция $f(x)$ имеет минимум на отрезке $x\in[a,b]$, 
то справедливо утверждение:
\begin{equation*}
f(a)\geqslant f(x_1),\quad f(x_2)\leqslant f(b)
\end{equation*}

Сравним все четыре значения функции между собой 
$f(a)$, $f(x_1)$, $f(x_2)$ и $f(b)$ и выберем среди них наименьшее.

%
%	График функций
%
\begin{figure}[H]\centering
\begin{tikzpicture}
\begin{axis}
[
xlabel={\empty},	% подпись оси x
ylabel={$f(x)$},	% подпись оси y
enlargelimits=true,
xmin=0, xmax=3, xtick={0,0.75,2.25,3}, xticklabels={$a$,$x_1$,$x_2$,$b$},
ymin=0, ymax=2, ytick={1,{0.25^2},{1+ln(2.25-0.75)},{1+ln(3-0.75)}}, yticklabels={},
%ytick={\empty}
]
\path[name path=O] (axis cs:0,0) -- (axis cs:2.25,0);
% функция f(x)
\addplot[name path=A1,thick,color=darkred,domain=0:1.5, samples=50] {(x-1)^2};
\addplot[name path=A2,thick,color=darkred,domain=1.5:3, samples=50] {1+ln(x-0.75)};
% область
\addplot [orange!15] fill between [of=A1 and O, soft clip={domain=0:1.5}];
\addplot [orange!15] fill between [of=A2 and O, soft clip={domain=1.5:2.25}];
% маркеры
\addplot[only marks,ball darkred] coordinates{(0,1)}
node[above]{$f(a)$};
\addplot[only marks,ball darkred] coordinates{(3,{1+ln(3-0.75)})}
node[above]{$f(b)$};
\addplot[only marks,ball darkblue] coordinates{(0.75,{0.25^2})}
node[above right]{$f(x_1)$};
\addplot[only marks,ball darkblue] coordinates{(2.25,{1+ln(2.25-0.75)})}
node[below right]{$f(x_2)$};
\end{axis}
\end{tikzpicture}
\caption{График кусочно-непрерывной функции $y=f(x)$,\linebreak
имеющей минимум на отрезке $x\in[a,b]$}
\label{fig:GD:f(x)=min}
\end{figure}

Из рисунка \ref{fig:GD:f(x)=min} видно, что наименьшее значение
функция достигает в точке $x=x_1$:
\begin{equation*}
f(x_1)<f(a)<f(x_2)<f(b)
\end{equation*}

Очевидно, что минимум функции $f(x)$ расположен в одном 
из прилегающих к точке $x=x_1$ отрезков, то есть минимум 
находится либо в пределах отрезка $[a,x_1]$, либо в $[x_1,x_2]$
(рисунок \ref{fig:GD:f(x)=min}, выделенная область).

Поэтому на первом шаге итерационного процесса 
отбрасывается отрезок $[x_2,b]$, и для поиска 
минимума функции $f(x)$ рассматривается отрезок $[a,x_2]$,
при этом область поиска минимума функции сужается:
\begin{equation*}
\abs{a-x_2}<\abs{a-b},\quad\text{так как}\quad x_2<b.
\end{equation*} 

Полагая $b=x_2$, на новом отрезке $[a, b]$ вновь необходимо 
выбрать две внутренние точки, вычислить в них и 
на концах отрезка значения функции $f(x)$, 
и сделать следующий шаг итерационного процесса.

Критерием остановки итерационного процесса является условие выполнения
неравенства, которое гарантирует малость размера области поиска
минимума по сравнению с заранее заданной погрешность метода:
\begin{equation*}
(b-a)\leqslant\epsilon,
\end{equation*}
где $\epsilon$ -- погрешность метода.

\emph{Симметричный метод} поиска минимума функции 
одной переменной $f(x)$ основан на выборе внутренних точек 
$x_1$ и $x_2$ отрезка $[a,b]$, 
которые равноудалены от концов этого отрезка.
Например, если точки $x_1$ и $x_2$ делят отрезок $[a,b]$
на три равные части (рисунок \ref{fig:GD:ab}), 
то координаты этих точек могут быть 
определены из соотношений:
\begin{equation*}
x_1=a+\dfrac{b-a}{3}=\dfrac{2a+b}{3},
\quad
x_2=b-\dfrac{b-a}{3}=\dfrac{a+2b}{3}.
\end{equation*}

\begin{figure}[H]\centering
\begin{tikzpicture}
[>={Straight Barb[angle=45:2mm 1]},shorten >=1pt,font=\small]% стрелка
% начало отсчета
\coordinate (O) at (0mm,0mm);
% ось OX
\draw[->,line width=0.25mm] ([xshift=-20mm]O) -- (80mm,0mm)
node[pos=1,yshift=-1em]{$x$};
% сетка
\coordinate (p) at (O);
\foreach \x [count=\n from 0] in {0,20,20,20}{
\path (p) -- ++(\x mm,0mm) coordinate(p);
\draw[fill=black] (p) circle[radius=0.8mm] coordinate(p\n);
}
% подписи
\draw (p0) node[above]{$a$};
\draw (p1) node[above]{$x_1$};
\draw (p2) node[above]{$x_2$};
\draw (p3) node[above]{$b$};
% штриховка
\begin{scope}[on background layer]
\pattern[pattern=north east lines,pattern color=gray,opacity=0.75]
(p0) -- ([yshift=-2mm]p0) -- ([yshift=-2mm]p3) -- (p3) -- cycle;
\end{scope}
\end{tikzpicture}
\caption{Схематическое изображение точек деления отрезка $[a,b]$}
\label{fig:GD:ab}
\end{figure}

Оценка длины отрезка после первого итерационного шага составит:
\begin{equation*}
\ell_1=(b-a) - \dfrac{b-a}{3}=\dfrac{2}{3}\cdot(b-a),
\end{equation*}
после второго шага:
\begin{equation*}
\ell_2=\ell_1-\dfrac{\ell_1}{3}=\dfrac{2}{3}\cdot\ell_1=
\left(\dfrac{2}{3}\right)^2\cdot(b-a),
\end{equation*}
а после $k$-ого итерационного шага:
\begin{equation*}
\ell_k=\left(\dfrac{2}{3}\right)^k\cdot(b-a).
\end{equation*}

Таким образом, чтобы погрешность вычисления 
$\ell_k$ была менее $\epsilon$, для числа итераций $k$ 
справедлива оценка:
\begin{equation*}
\left(\dfrac{2}{3}\right)^k\cdot(b-a)\leqslant\epsilon
\quad\to\quad
k=\left\lceil\dfrac{\ln(b-a)-\ln(\epsilon)}{\ln(3)-\ln(2)}\right\rceil
\end{equation*}

Симметричный метод поиска минимума функции является 
аналогом метода дихотомии для нахождения корня уравнения $f(x)=0$. 
Метод применим к недифференцируемым функциям и всегда 
сходится. 
Следует отметить, что если на отрезке $[a,b]$
функция $f(x)$ имеет несколько локальных минимумов, 
то итерационный процесс сойдется к одному из этих минимумов, 
но не обязательно к наименьшему. 

% *** Алгоритм поиска минимума функции одной переменной
% https://tex.stackexchange.com/questions/370704/drawing-a-scheme
\begin{figure}[H]\centering
\begin{tikzpicture}[
font=\small,
start chain=going below,node distance=10mm,every join/.style=->,%
>={Straight Barb[angle=45:1.5mm 1]},shorten >=0.5pt,%
]
% соединитель
\node[rrectnode,on chain,join]{старт};
% данные
\node[datanode,on chain,join]
{$a, b, \epsilon$};
% x1, x2
\node[rectnode,on chain,join](x1x2)
{$x_1=\dfrac{2a+b}{3},\;x_2=\dfrac{a+2b}{3}$};
% f(x1) < f(x2)
\node[ifthenelsenode,on chain,join](compare)
{$f(x_1)>f(x_2)$};
% да
\begin{scope}[start branch=a,node distance=15mm]
\node[rectnode,on chain=going left,join](a)
{$a=x_1$};
\draw(compare.west) node[above left]{да};
\end{scope}
% нет
\begin{scope}[start branch=b,node distance=15mm]
\node[rectnode,on chain=going right,join](b)
{$b=x_2$};
\draw(compare.east) node[above right]{нет};
\end{scope}
% ошибка
\node[rectnode,on chain](error)
{$\Delta=b-a$};
% связи
\draw[->] (a.south) |- (error.west);
\draw[->] (b.south) |- (error.east);
% выход?
\node[ifthenelsenode,on chain,join](exit)
{$\Delta<\epsilon$};
\draw (exit.east) node[above right]{нет};
\draw[->,thick] (exit.east) -- ([xshift=5cm]exit.east) |- (x1x2.east);
% соединитель
\draw (exit.south) node[below left]{да};
\begin{scope}[node distance=12mm]
\node[rrectnode,on chain,join]{стоп};
\end{scope}
\end{tikzpicture}
% *******************************************
\caption{Блок-схема алгоритма нахождения минимума\linebreak 
функции $f(x)$ одного переменного}
\label{fig:GD:scheme f(x)->min}
\end{figure}

%
% Минимум функции многих переменных
%
\emptyline
\subsection{Минимизация функций многих переменных}

Задача безусловной минимизации (оптимизации) 
состоит в нахождении минимума или максимума функции $f(\vect{x})$
в отсутствие каких-либо ограничений на область изменения
переменных задачи $\vect{x}\in(-\infty,+\infty)$.

Большинство практических задач оптимизации 
содержит ограничения, которые обусловлены 
технико-экономическим смыслом решаемой задачи,
однако многие алгоритмы решения задач с ограничениями 
предполагают сведение ее к последовательности задач 
безусловной оптимизации.

% Спуск по координатам
\emptyline
\subsubsection{Спуск по координатам}
Идея метода по координатного спуска заключается в том, что
задача поиска минимума функции $f(x_1,x_2,\ldots,x_n)\to\min$
разделяется на серию задач \alert{одномерной минимизации} 
этой функции вдоль направления одной из координатных осей:
\begin{equation*}
\begin{matrix}
f(\textcolor{darkred}{x_1},x_2=\const,\ldots,x_n=\const)\to\min\\
f(x_1=\const,\textcolor{darkred}{x_2},\ldots,x_n=\const)\to\min\\
\hdotsfor{1}\\
f(x_1=\const,x_2=\const,\ldots,\textcolor{darkred}{x_n})\to\min\\
\end{matrix}
\end{equation*}

\begin{enumerate}
\item
Выбирают нулевое приближение 
$\vect{x}_0=(x_{10},x_{20},\ldots,x_{n0})$.
\item
Фиксируют (считают постоянными)  значения всех 
координат кроме $x_1$. Тогда функция $f(\vect{x})$
будет зависеть только от одной переменной $x_1$:
\begin{equation*}
\phi_1(x_1)=f(x_1,x_{20}=\const,\ldots,x_{n0}=\const)
\end{equation*}
\item
Используя метод одномерной минимизации, находится 
минимум функции одной переменной $\phi_1(x_1)\to\min$, 
который можно обозначить через $m_1$.
\item
Сделан переход из начальной точки $\vect{x}_0$ в точку
``частного`` минимума по направлению, параллельному оси $x_1$:
\begin{equation*}
(x_{10},x_{20},\ldots,x_{n0})\to(m_1,x_{20},\ldots,x_{n0}),
\end{equation*}
и значение функции уменьшается:
\begin{equation*}
f(x_{10},x_{20},\ldots,x_{n0})>f(m_1,x_{20},\ldots,x_{n0})
\end{equation*}
\item
Затем из новой точки $(m_1,x_{20},\ldots,x_{n0})$
осуществляется спуск по направлению, параллельному оси $x_2$,
то есть находится минимум функции: 
\begin{equation*}
\phi_2(x_2)=f(m_1=\const,x_2,\ldots,x_n=\const),
\end{equation*}
который обозначим $m_2$.
\item
Таким образом, сделан переход во вторую точку
``частного`` минимума по направлению, параллельному оси $x_2$:
\begin{equation*}
(m_1,x_{20},\ldots,x_{n0})\to(m_1,m_2,\ldots,x_{n0}),
\end{equation*}
и значение функции уменьшается:
\begin{equation*}
f(m_1,x_{20},\ldots,x_{n0})>f(m_1,m_2,\ldots,x_{n0})
\end{equation*}
\item
Процесс спуска по координатам повторяется для всех переменных
задачи $x_3,x_4,\ldots,x_n$, а приход в точку 
$\vect{x}_m=(m_1,m_2,\ldots,m_n)$ завершает цикл спусков.
\item
Конечную точку цикла спусков можно принять за нулевое 
приближение\linebreak $\vect{x}_0=\vect{x}_m$ 
и повторить цикл спусков по координатам $x_1,x_2,\ldots,x_n$
до тех пока, не выполнено условие останова 
итерационного процесса.
\end{enumerate}

\emptyline
Практически можно задать некоторое число $\epsilon > 0$, 
связанное с выбранной точностью вычислений, и 
проводить итерации до тех пор, пока на $k$-ой итерации
не будут выполнены одно или несколько неравенств вида:
\begin{equation}
\norma{\vect{x}_k - \vect{x}_{k-1}} < \epsilon_1,
\quad
\norma{f(\vect{x}_k)-f(\vect{x}_{k-1})} < \epsilon_2
\end{equation}

\emptyline
\subsubsection{Нахождение оптимальных 
географических координат склада торговой сети}




Географические координаты определяют местоположение 
точки на поверхности Земли, и строятся по принципу 
сферических координат. Центр системы географических координат
помещается в центр Земли, а положение точки определяется
расстоянием $r$ от центра Земли, широтой $\lambda$ и долготой $\phi$
(рисунок \ref{fig:GCS}).

Долгота $\lambda$ -- двугранный угол между плоскостью меридиана, 
проходящего через данную точку, и плоскостью начального 
нулевого меридиана.

Широта $\phi$ -- угол между местным направлением зенита и 
плоскостью экватора, отсчитываемый в обе стороны от экватора.

Радиус-вектор $\vect{r}$ точки $A$, находящейся 
на поверхности Земли, имеет в декартовой системе 
координат компоненты:
\begin{equation*}
\vect{r}=(r_x,r_y,r_z),
\end{equation*}
где $r_{x,y,z}$ -- компоненты вектора $\vect{r}$, 
то есть проекции этого вектора на оси декартовой системы координат:
\begin{equation*}
\left\{\begin{matrix}[lcl]
r_x&=&\mathcal{R}\cdot\cos(\phi)\cdot\cos(\lambda)\\
r_y&=&\mathcal{R}\cdot\cos(\phi)\cdot\sin(\lambda)\\
r_z&=&\mathcal{R}\cdot\sin(\phi)\\
\end{matrix}\right.,
\end{equation*}
$\mathcal{R}$ -- радиус планеты Земля.

%
% 3D-МОДЕЛЬ географических координат
%
% географическая система координат
\newcommand\GScoordinate[4]{
\coordinate (#1) at ({#2*cos(#3)*cos(#4)},{#2*cos(#3)*sin(#4)},{#2*sin(#3)});
\coordinate (#1x) at ({#2*cos(#3)*cos(#4)},0,0);
\coordinate (#1y) at (0,{#2*cos(#3)*sin(#4)},0);
\coordinate (#1z) at (0,0,{#2*sin(#3)});
\coordinate (#1xy) at ({#2*cos(#3)*cos(#4)},{#2*cos(#3)*sin(#4)},0);
}
% 3D-вид 
\tdplotsetmaincoords{60}{120}
\begin{figure}[H]\centering
\begin{tikzpicture}[tdplot_main_coords,scale=4.5,
>={Straight Barb[angle=45:1.5mm 1]},shorten >=2pt]
% радиус Земли
\def\radiusX{1.1}
% центр Земли
\coordinate (O) at (0,0,0);
% Земля
\shadedraw[color=darkblue,thick,ball color=blue!25!white,opacity=0.5,rotate=30] 
(O)  circle({\radiusX cm});
% экватор
\fill[color=blue!25,opacity=0.25] 
(0,0) circle({\radiusX});
\tdplotsetrotatedcoords{-60}{0}{0};
\draw[tdplot_rotated_coords,darkblue,thick]
(\radiusX,0) arc (0:180:{\radiusX})
node[sloped,pos=0.5,below,font=\small]{экватор};
\draw[tdplot_rotated_coords,dashed,darkblue,opacity=0.5]
(\radiusX,0) arc (360:180:{\radiusX});

% система координат
%\tdplotsetrotatedcoords{0}{0}{0};
\begin{scope}[font=\footnotesize,color=gray]
\draw[->] (O) -- (0.8,0,0) node[above left] {$x$};
\draw[->] (O) -- (0,0.9,0) node[above right] {$y$};
\draw[->] (O) -- (0,0,1.1) node[left] {$z$};
\end{scope}
% точка на поверхности Земли
\def\radius{1.25}\def\longitude{60}\def\latitude{45}
% xyz-координаты
\GScoordinate{A}{\radius}{\latitude}{\longitude};
% прорисовка проекций
\draw[fill=orange!25,opacity=0.25] (O) -- (Az) -- (A) -- (Axy) -- (O);
% углы
\path (O) -- (Ax) node[pos=1](AX){};
\path (O) -- (Axy) node[pos=0.5](AXY){};
\path (O) -- (A) node[pos=0.5](AR){};
% прорисовка углов
\begin{scope}[font=\small]
% широта
\draw[->,thick,color=blue]  (AX.center) 
to [bend right=30]node[sloped,pos=0.5,below]{$\lambda$}
(AXY.center);
% долгота
\draw[->,thick,color=red]  (AXY.center) 
to [bend right=30]node[pos=0.5,right]{$\phi$}
(AR.center);
\end{scope}
%\begin{scope}[shift={(0,0,{\Pz})}]
%\tdplotsetrotatedcoords{-49}{0}{0};
%\def\radiusY{\radius*cos(\latitude)}
%\draw[tdplot_rotated_coords,thin,blue,opacity=0.5] 
%({\radiusY},0) arc(0:160:{\radiusY});
%\end{scope}
% радиус-вектор
\draw[->,thick,black]
(O) -- (A) node[sloped,pos=0.5,above]{$\vect{r}$};
\draw[thick,fill=white]
(A) circle(0.5pt) node[below right]{$A$};
\end{tikzpicture}
\caption{
\href{https://en.wikipedia.org/wiki/Geographic_coordinate_system\#Latitude_and_longitude}
{Географическая система координат} на поверхности Земли}
\label{fig:GCS}
\end{figure}

Кратчайшее расстояние между двумя точками $A$ и $B$
находящимися на сферической поверхности Земли
равно длине дуги большого круга.
Если известны географические координатами точек
$A(\phi_a,\lambda_a)$ и $B(\phi_b,\lambda_b)$, то
расстояние на поверхности Земли между этими точками
составляет (рисунок \ref{fig:GCS:creat circle distance}):
\begin{equation}\label{eq:GCS:sphere distance}
d_{AB}=\mathcal{R}\cdot\alpha,
\end{equation}
где $\alpha$ -- центральный угол между радиус-векторами
$\vect{a}$ и $\vect{b}$ 
точек $A$ и $B$, лежащих на поверхности Земли.

%
% График: длина дуги большого круга
%
\tdplotsetmaincoords{60}{120}
\begin{figure}[H]\centering
\begin{tikzpicture}[tdplot_main_coords,scale=4.5,
>={Straight Barb[angle=45:1.5mm 1]},shorten >=2pt]
% радиус Земли
\def\radiusX{1.1}
% центр Земли
\coordinate (O) at (0,0,0);
% Земля
\shadedraw[color=darkblue,thick,ball color=blue!25!white,opacity=0.5,rotate=30] 
(O)  circle({\radiusX cm});
% экватор
\fill[color=blue!25,opacity=0.25] 
(0,0) circle({\radiusX});
\tdplotsetrotatedcoords{-60}{0}{0};
\draw[tdplot_rotated_coords,darkblue,thick]
(\radiusX,0) arc (0:180:{\radiusX})
node[sloped,pos=0.5,below,font=\small]{экватор};
\draw[tdplot_rotated_coords,dashed,darkblue,opacity=0.5]
(\radiusX,0) arc (360:180:{\radiusX});

% система координат
%\tdplotsetrotatedcoords{0}{0}{0};
\begin{scope}[font=\footnotesize,color=gray]
\draw[->] (O) -- (0.8,0,0) node[above left] {$x$};
\draw[->] (O) -- (0,0.9,0) node[above right] {$y$};
\draw[->] (O) -- (0,0,1.1) node[left] {$z$};
\end{scope}
 
% центр сферы
\tdplotsetcoord{O}{0}{0}{0};
% координат точек
\GScoordinate{A}{1}{40}{70};
\GScoordinate{B}{1}{60}{-30};
% плоскость
\filldraw[color=gray,fill=orange!20,opacity=0.5]
(O) -- (A) to [bend right=50] (B) -- (O);
% дуга
\draw[black,thick,tdplot_main_coords]
(A) to [bend right=50]node[sloped,pos=0.5,above]{$d_{AB}$} (B);
% точки на сфере 
\draw[fill=red] (A) circle (0.5pt) node[below right,color=red]{$A$};
\draw[fill=blue] (B) circle (0.5pt) node[above left,color=blue]{$B$};
% радиус-вектор
\draw[->,red,thick] (0,0,0) -- (A)
node[sloped,pos=0.5,below]{$\vect{r}_1$};
\draw[->,blue,thick] (0,0,0) -- (B)
node[sloped,pos=0.5,below]{$\vect{r}_2$};
% угол
\path (O) -- (A) node[pos=0.35](AA){};
\path (O) -- (B) node[pos=0.35](AB){};
\draw[<->] (AA.center) to [bend right=40]
node[pos=0.25,above]{$\alpha$} (AB.center);
\end{tikzpicture}
\caption{Расстояние $d_{AB}$ (длина дуги) на поверхности сферы
между точками $A$ и $B$}
\label{fig:GCS:creat circle distance}
\end{figure}

Косинус угла $\alpha$ между векторами $\vect{a}$ и $\vect{b}$
можно определить, воспользовавшись геометрическим свойством
скалярного произведения этих векторов:
\begin{equation}\label{eq:GD:cos(a,b)}
(\vect{a},\vect{b}) = \norma{\vect{a}}\cdot\norma{\vect{b}}
\cdot\cos(\alpha)
\quad\to\quad
\cos(\alpha)=
\dfrac{(\vect{a},\vect{b})}{\norma{\vect{a}}\cdot\norma{\vect{b}}},
\end{equation}
где $\norma{\vect{a}}=\norma{\vect{b}}=\mathcal{R}$ --
длины радиус-векторов, с учетом постоянства радиуса Земли.

С алгебраической точки зрения, 
\emph{скалярное произведение векторов} -- это операция 
над двумя векторами $\vect{a}$ и $\vect{b}$, 
результатом которой является число (скаляр), 
значение которого не зависит от выбранной системы координат,
то есть скалярное произведение является \emph{инвариантом}:
\begin{equation}\label{eq:vector scalar product}
(\vect{a},\vect{b})=a_{x}\cdot b_{x} + a_y\cdot b_y + a_z\cdot b_z,
\end{equation}
где $a_{x,y,z}$ и $b_{x,y,z}$ -- компоненты векторов
в декартовой системе координат:
% a
\begin{equation}\label{eq:GD:vector a}
\vect{a}=\left\{\begin{matrix}[rcl]
a_x&=&\mathcal{R}\cdot\cos(\phi_a)\cdot\cos(\lambda_a)\\
a_y&=&\mathcal{R}\cdot\cos(\phi_a)\cdot\sin(\lambda_a)\\
a_z&=&\mathcal{R}\cdot\sin(\phi_a)\\
\end{matrix}\right.
\end{equation}
% b
\begin{equation}\label{eq:GD:vector b}
\vect{b}=\left\{\begin{matrix}[rcl]
b_x&=&\mathcal{R}\cdot\cos(\phi_b)\cdot\cos(\lambda_b)\\
b_y&=&\mathcal{R}\cdot\cos(\phi_b)\cdot\sin(\lambda_b)\\
b_z&=&\mathcal{R}\cdot\sin(\phi_b)\\
\end{matrix}\right.
\end{equation}

Косинус угла \eqref{eq:GD:cos(a,b)} между векторами 
$\vect{a}$ и $\vect{b}$ с учетом 
\eqref{eq:GD:vector a} и \eqref{eq:GD:vector b}:
\begin{equation*}
\begin{split}
\cos(\alpha)=\;
&\cos(\phi_a)\cos(\lambda_a)\cdot\cos(\phi_b)\cos(\lambda_b)\;+\\
&\cos(\phi_a)\sin(\lambda_a)\cdot\cos(\phi_b)\sin(\lambda_b)\;+\\
&\sin(\phi_a)\cdot\sin(\phi_b)
\end{split}
\end{equation*}
или
\begin{equation*}
\begin{split}
\cos(\alpha)=\cos(\phi_a)\cos(\phi_b)\cdot
\begin{pmatrix}[l]
\cos(\lambda_a)\cdot\cos(\lambda_b)\;+\\
+\sin(\lambda_a)\cdot\sin(\lambda_b)
\end{pmatrix}+
\sin(\phi_a)\sin(\phi_b)
\end{split}
\end{equation*}

Воспользовавшись формулой для разности углов 
тригонометрических функций (косинуса):
\begin{equation*}
\cos(\lambda_a)\cdot\cos(\lambda_b)+
\sin(\lambda_a)\cdot\sin(\lambda_b)=
\cos(\lambda_a - \lambda_b)
\end{equation*}
окончательно получим:
\begin{equation*}
\cos(\alpha)=
\cos(\phi_a)\cos(\phi_b)\cdot\cos(\Delta\lambda) +
\sin(\phi_a)\sin(\phi_b),
\end{equation*}
где $\Delta\lambda=\lambda_a-\lambda_b$ --
разность долготы географических координат точек $A$ и $B$,
соответственно.

Таким образом, кратчайшее расстояние на поверхности Земли
между двумя точками \eqref{eq:GCS:sphere distance}
может быть найдено из соотношения:
\begin{equation}\label{eq:GCS:distance}
d_{AB}=\mathcal{R}\cdot\arccos\left(
\cos(\phi_a)\cos(\phi_b)\cdot\cos(\Delta\lambda) +
\sin(\phi_a)\sin(\phi_b)
\right),
\end{equation}

\begin{enumerate}
\item
С помощью картографических веб сервисов (например, 
\href{https://yandex.ru/maps}{Яндекс.Карты},
\href{https://www.google.ru/maps}{карты Google}, и т.п.).
определим 
\href{https://ru.wikipedia.org/wiki/Географические_координаты}
{географические координаты} всех городов, 
в которых находятся магазины торговой сети 
Полученные данные представим в таблице \ref{tab:cities}.

%
% Таблица: города торговой сети
%
\begin{table}[H]
\caption{Географические координаты магазинов торговой сети}
\label{tab:cities}
\begin{tabular*}{\textwidth}{%
@{\extracolsep{\fill}}p{7cm} p{3cm} p{3cm}}
\toprule
Город&%
\multicolumn{2}{l}{Географические координаты}\\
\cmidrule{2-3}
&широта $\phi$&долгота $\lambda$\\
\midmidrule
Москва&$55.664$&$37.630$\\
Саратов&$51.534$&$46.031$\\
Воронеж&$56.671$&$39.162$\\
\bottomrule
\end{tabular*}
\end{table}

\item
Построим целевую функцию $r=f(\phi,\lambda)$ -- 
суммарное расстояние вдоль поверхности Земли 
от склада до магазинов в городах Москва, Саратов и Воронеж:
\begin{equation*}\label{eq:r(phi,lambda)}
r(\phi,\lambda)=d_1(\phi,\lambda)+d_2(\phi,\lambda)+d_3(\phi,\lambda),
\end{equation*}
где $\phi$ и $\lambda$ -- географическая широта и долгота 
местоположения склада;
$d_1$, $d_2$ и $d_3$ -- расстояние вдоль поверхности Земли
\eqref{eq:GCS:distance} между складом и городами 
Москва, Саратов и Воронеж, соответственно:
\begin{gather*}
d_1(\phi,\lambda)=\mathcal{R}\cdot\arccos\left(
\cos(\phi)\cos(\phi_1)\cdot\cos(\lambda-\lambda_1) +
\sin(\phi)\sin(\phi_1)
\right)\\
d_2(\phi,\lambda)=\mathcal{R}\cdot\arccos\left(
\cos(\phi)\cos(\phi_2)\cdot\cos(\lambda-\lambda_2) +
\sin(\phi)\sin(\phi_2)
\right)\\
d_3(\phi,\lambda)=\mathcal{R}\cdot\arccos\left(
\cos(\phi)\cos(\phi_3)\cdot\cos(\lambda-\lambda_3) +
\sin(\phi)\sin(\phi_3)
\right)
\end{gather*}
где 
$\phi_1=55.664$ и $\lambda_1=37.630$ -- долгота и широта города Москва;\\
$\phi_2=51.534$ и $\lambda_2=46.031$ -- долгота и широта города Саратов;\\
$\phi_3=56.671$ и $\lambda_3=39.162$ -- долгота и широта города Воронеж
(таблица \ref{tab:cities}).

\item
Для решения задачи оптимизации целевой функции 
\alert{методом по координатного спуска} 
определим область поиска минимума функции $r(\phi,\lambda)$.

Например, в качестве границ области можно выбрать
экстремальные значения широты и долготы городов, 
в которых расположены магазины торговой сети:
\begin{gather*}
\left\{\begin{matrix}[lclcl]
\phi_{\mathrm{start}}&=&\min(\phi_1,\phi_2,\phi_3) = \phi_2&=&51.534\\
\phi_{\mathrm{end}}&=&\max(\phi_1,\phi_2,\phi_3) = \phi_3&=&56.671\\
\end{matrix}\right.
\\
\left\{\begin{matrix}[lclcl]
\lambda_{\mathrm{start}}&=&\min(\lambda_1,\lambda_2,\lambda_3)=\lambda_1&=&37.630\\
\lambda_{\mathrm{end}}&=&\max(\lambda_1,\lambda_2,\lambda_3)=\lambda_2&=&46.031\\
\end{matrix}\right.
\end{gather*}

Таким образом, минимум целевой функции будем искать в области:
\begin{equation*}
\left\{\begin{matrix}[rcl]
\phi_{\mathrm{start}}&\leqslant \phi \leqslant&\phi_{\mathrm{end}}\\
\lambda_{\mathrm{start}}&\leqslant \lambda \leqslant&\lambda_{\mathrm{end}}\\
\end{matrix}\right.
\quad\to\quad
\left\{\begin{matrix}[rcl]
51.534&\leqslant \phi \leqslant&56.671\\
37.630&\leqslant \lambda \leqslant&46.031\\
\end{matrix}\right.
\end{equation*}

\item
Критерием прекращения итерационного поиска
минимума целевой функции будем считать условие выполнения
неравенства:
\begin{equation*}
\xi\leqslant\epsilon_1,
\end{equation*}
где $\epsilon_1=10^{-2}$ -- заданная точность
определения местоположения склада;\linebreak
$\xi$ -- изменение местоположения склада 
на текущем $k$ шаге итерационного процесса:
\begin{equation}\label{eq:GCS:step error}
\xi=\sqrt{(\phi_k-\phi_{k-1})^2+(\lambda_k-\lambda_{k-1})^2};
\end{equation}
$\phi_k$ и $\lambda_k$ -- значение географических координат
склада на $k$-ом шаге итерационного процесса.

\item
В качестве начального местоположение склада
$(\phi_0,\lambda_0)$ выберем любую произвольную
точку внутри области поиска минимума целевой функции:
\begin{equation*}
\begin{cases}
\phi_0 = 51.534\\
\lambda_0 = 46.031\\
\end{cases}.
\end{equation*}

\item
Считаем постоянными значения долготы склада 
$\lambda=\lambda_0=\const$
и рассматриваем вспомогательную функцию
только одной переменной $\phi$:
\begin{equation*}
\rho(\phi)=r(\phi, \lambda_0)=r(\phi, 46.031)
\end{equation*}

Находим минимум функции одной переменной $\rho(\phi)$,
используя метод одномерной минимизации:
\begin{equation*}
\rho(\phi_{\min})\to\min,\qquad\phi_{\min}=53.946
\end{equation*}
где $\phi_{\min}$ -- положение минимума
вспомогательной функции $\rho(\phi)=r(\phi, 46.031)$.

Считаем постоянными значения широты склада 
$\phi=\phi_{\min}=\const$ 
и рассматриваем вспомогательную функцию
только одной переменной $\lambda$:
\begin{equation*}
\rho(\lambda)=r(\phi_{\min},\lambda)=r(53.946,\lambda)
\end{equation*}

Находим минимум функции одной переменной $\rho(\lambda)$,
используя метод одномерной минимизации:
\begin{equation*}
\rho(\lambda_{\min})\to\min,\qquad\lambda_{\min}=40.209
\end{equation*}
где $\lambda_{\min}$ -- положение минимума
вспомогательной функции $\rho(\lambda)=r(53.946 ,\lambda)$.

\item
Определяем изменение местоположения склада 
\eqref{eq:GCS:step error} в результате проведенных 
итерационных процессов (рисунок \ref{fig:min1}):
\begin{equation*}
\begin{split}
\xi=\;
&\sqrt{(\phi_{\min}-\phi_0)^2+(\lambda_{\min}-\lambda_0)^2}=\\
=\;&\sqrt{(53.946-51.534)^2+(40.209-46.031)^2}=\\
=\;&6.3019\\
\end{split}
%\leqslant\epsilon_1=10^{-2},
\end{equation*}

Сравниваем величину текущего ``шага`` $\xi$ и 
заданную точность расчетов $\epsilon_1$:
\begin{gather*}
\xi=6.3019>10^{-2}=\epsilon_1
\end{gather*}
Величина текущего ``шага`` $\xi$ больше заданной 
точности расчетов $\epsilon_1$,
следовательно, \emph{итерационный процесс продолжаем}!

%
% График: траектория поиска минимума
%
\begin{figure}[H]\centering
\begin{tikzpicture}[>={Straight Barb[angle=45:1.5mm 1]},shorten >=2pt,shorten <=2pt]
\begin{axis}[enlargelimits=0.2,xtick={},ytick={},
xlabel={широта $\phi$},ylabel={долгота $\lambda$},
%y dir=reverse
]
%% изолинии

%% местонахождение городов
%\addplot[ball darkblue,only marks]coordinates{(55.664,37.630)(51.534,46.031)(56.671,39.162)};
\addplot[ball darkblue,only marks]coordinates{(55.664,37.630)}
node[below,text=black]{Москва};
\addplot[ball darkblue,only marks]coordinates{(51.534,46.031)}
node[above,text=black]{Саратов};
\addplot[ball darkblue,only marks]coordinates{(56.671,39.162)}
node[above,text=black]{Воронеж};
%% начальная точка
\addplot[darkred]coordinates{(51.534,46.031)}
node[below,xshift=+7pt,fill=white]{$(\phi_0,\lambda_0)$};
%% смещение по phi
\addplot[darkred,->]coordinates{(51.534,46.031) (53.946,46.031)}
node[right,fill=white]{$(\phi_{\min},\lambda_0)$};
%% смещение по lambda
\addplot[darkred,->]coordinates{(53.946,46.031) (53.946,40.209)};
%% конечное положение
\addplot[darkred]coordinates{(53.946,40.209)}
node[left,fill=white,xshift=-5pt]{$(\phi_{\min},\lambda_{\min})$};
%% результирующее смещение
\addplot[black,thin,->]coordinates{(51.534,46.031) (53.946,40.209)}
node[sloped,pos=0.5,above]{$\xi$};
%\addplot[darkred]coordinates{(53.946,40.209)(55.808,40.209)(55.808,38.780)(55.868,38.780)(55.868,38.828)(55.880,38.828)(55.880,38.839)(55.880,38.839)(55.880,38.839)};
%% начальное положение
%\addplot[darkred,mark=*]coordinates{(51.534,46.031)};
\end{axis}
\end{tikzpicture}
\caption{``Рельеф`` целевой функции $r(\phi,\lambda)$ и 
``траектория`` поиска местоположения склада $(\phi,\lambda)$
торговой сети (маркерами обозначены города)}
\label{fig:min1}
\end{figure}

\item
За новое местоположение склада торговой сети 
принимается положение ``частного`` минимума 
целевой функции на предыдущем шаге итерационного процесса:
\begin{equation*}
\left\{\begin{matrix}[lcl]
\phi_0 = \phi_{\min}&=&53.946\\
\lambda_0 = \lambda_{\min}&=&40.209\\
\end{matrix}\right.
\end{equation*}
и итерационный процесс повторяется!

\item
Считаем постоянными значения долготы склада 
$\lambda=\lambda_0=\const$
и рассматриваем вспомогательную функцию
только одной переменной $\phi$:
\begin{equation*}
\rho(\phi)=r(\phi, \lambda_0)=r(\phi,40.209)
\end{equation*}

Находим минимум функции одной переменной $\rho(\phi)$,
используя метод одномерной минимизации:
\begin{equation*}
\rho(\phi_{\min})\to\min,\qquad\phi_{\min}=55.808
\end{equation*}
где $\phi_{\min}$ -- положение минимума
вспомогательной функции $\rho(\phi)=r(\phi,40.209)$.


%\item
%С помощью метода по координатного спуска,
%определим оптимальные географические координаты склада 
%$(\phi_{\min}, \lambda_{\min})$, при которых 
%суммарное расстояние $r(\phi,\lambda)$ от склада до 
%всех магазинов торговой сети в городах Москва, Саратов и Воронеж
%минимально.

\end{enumerate}

%%
%% 2D-график
%%
%\begin{figure}[H]\centering
%\begin{tikzpicture}[%
%>={Straight Barb[angle=45:1.5mm 1]},shorten >=2pt,%
%]
%\begin{axis}[
%axis on top,enlargelimits=true,
%ylabel={широта $\phi$},xlabel={долгота $\lambda$},
%%xtick=\empty,ytick=\empty,
%ymin=53,ymax=58,xmin=36,xmax=44,
%]
%\addplot[black!90,smooth]
%plot table [y={latitude},x={longitude}]{chapter/counter1.txt}
%node[pos=0.7,fill=white,xshift=+9pt,text=black]{\tiny$850$};
%\addplot[black!50,smooth]
%plot table [y={latitude},x={longitude}]{chapter/counter2.txt}
%node[pos=0.7,fill=white,xshift=+7pt,text=black]{\tiny$900$};
%\addplot[black!35,smooth]
%plot table [y={latitude},x={longitude}]{chapter/counter3.txt}
%node[pos=0.7,fill=white,xshift=+7pt,text=black]{\tiny$1000$};
%\addplot[black!20,smooth]
%plot table [y={latitude},x={longitude}]{chapter/counter4.txt}
%node[pos=0.7,fill=white,xshift=+7pt,text=black]{\tiny$1100$};
%% 'траектория' поиска минимума
%\addplot[red]
%plot table [y={latitude},x={longitude}]{chapter/path_min.txt};
%% начальная точка
%\addplot[only marks,ball darkred]
%coordinates {(36.7,53.5)} node[below,fill=white]{$(\lambda_0,\phi_0)$};
%%\addplot[->,darkred]
%%coordinates {(-3.000,-8.000) (0.747,-8.000) (0.747,-2.006) (-0.496,-2.006)};
%% конечная точка
%\addplot[only marks,ball darkred]
%coordinates {(38.840997,55.882960)};
%\end{axis}
%\end{tikzpicture}
%%\end{subfigure}
%\caption{``Рельеф`` функции двух переменных $r(\phi,\lambda)$}
%\end{figure}
    

% Метод градиентного спуска
\emptyline
\subsubsection{Метод градиентного спуска}
Градиентный спуск -- метод нахождения локального экстремума 
(минимума или максимума) функции многих переменных 
$f(x_1,x_2,\ldots,x_n)$
с помощью движения вдоль градиента этой функции. 
Это наиболее простой в реализации из всех методов локальной оптимизации, но имеет
относительно малую (линейную) скорость сходимости.

Градиент $\nabla$ это вектор, указывающий направление 
наибольшего возрастания некоторой функции
$f$, значение которой меняется от одной точки 
пространства к другой (скалярного поля), 
а по величине (модулю) равный скорости роста этой величины 
в этом направлении.
Компонентами вектора градиента являются частные производные 
$f$ по всем её аргументам:
\begin{equation}\label{eq:GD:nabla}
\nabla{f}=\left(\pdiff{f}{x_1},\pdiff{f}{x_2},\ldots,\pdiff{f}{x_n}\right)
\end{equation}

Для случая трёхмерного пространства градиентом 
скалярной функции\linebreak
$f(x,y,z)$ называется векторная функция:
\begin{gather*}
\mathrm{grad}\,f=\nabla{f},
\end{gather*}
где $\nabla$ -- векторный дифференциальный оператор набла,
компоненты которого являются частными производными 
по координатам:
\begin{gather*}
\nabla=\left(\pdiff{}{x}, \pdiff{}{y}, \pdiff{}{z}\right)
\end{gather*}

Следует отметить, что оператор набла не принадлежит тому же 
пространству, что и обычные векторы, а говоря точнее, 
скалярное и векторное произведение для него 
определено с некоторыми отличиями. 
Оператор $\nabla$ действует на те скалярные поля, 
что стоят от него справа, и не действует на стоящие от него слева.
Поэтому скалярное и векторное произведение с участием 
$\nabla$ \emph{не коммутативны} и не антикоммутативны, 
как это свойственно для таких произведений обычных векторов.

Минимизация целевой функции $f(\vect{x})$ 
сводится к итерационному процессу 
последовательного выбора нового 
вектора неизвестных $\vect{x}_{k+1}$, такого чтобы
значение функции в новой точки было меньше чем в предыдущих:
\begin{equation*}
f(\vect{x}_0)>f(\vect{x}_1)>\ldots>f(\vect{x}_k)>f(\vect{x}_{k+1})>\ldots
\end{equation*}

Предполагая, что новый вектор неизвестных мало отличается 
от предыдущего ($\vect{x}_{k+1}-\vect{x}_k\approx\vect{0}$),
можно воспользоваться линейным приближением
для разложения в ряд Тейлора целевой функции:
\begin{equation}\label{eq:GD:Taylor}
f(\vect{x}_{k+1}) = f(\vect{x}_k)
+\left(\nabla{f}(\vect{x}_k),\vect{x}_{k+1}-\vect{x}_k\right),
\end{equation}
где $k$ -- номер итерационного шага процесса;
$\vect{x}_k$ -- значение неизвестных на $k$-ой итерации.

Если в качестве нового вектора неизвестных выбрать:
\begin{equation}\label{eq:GD:x(k+1)}
\vect{x}_{k+1}=\vect{x}_k - \lambda\cdot\nabla{f(\vect{x}_k)},
\end{equation}
то из \eqref{eq:GD:Taylor} получим:
\begin{equation}
f(\vect{x}_{k+1}) = f(\vect{x}_k)
-\lambda\cdot\norma{\nabla{f}(\vect{x}_k)}^2
\quad\to\quad
f(\vect{x}_{k+1}) \leqslant f(\vect{x}_k)
\end{equation}
где $\lambda>0$ -- малое положительное число (параметр метода), 
имеющий смысл скорости градиентного спуска;
$\norma{\nabla{f}(\vect{x}_k)}\geqslant0$ -- 
норма вектора градиента (неотрицательное число):
\begin{equation*}
\norma{\nabla{f}}=\sqrt{\left(\nabla{f},\nabla{f}\right)}
\end{equation*}

Таким образом, выбор нового вектора неизвестных $\vect{x}_{k+1}$
в соответствии с выражением \eqref{eq:GD:x(k+1)}, гарантирует
монотонное убывание целевой функции $f(\vect{x})$ в каждой итерации.
Поэтому основная идея метода градиентного спуска заключается в том, 
чтобы последовательно идти в направлении наибольшего
уменьшения целевой функции, которое задаётся антиградиентом 
$-\nabla{f}(\vect{x})$.

% Алгоритм метода градиентного спуска
%\textbf{Алгоритм метода градиентного спуска}
%\begin{enumerate}
%\item 
%Задают начальное приближение ${(x_0,y_0)}$, 
%скорость градиентного спуска $\lambda$, 
%а также точность расчёта $\varepsilon$.
%\item
%Рассчитывают градиент целевой функции
%в текущей точке $\nabla_0=\nabla f(x_0,y_0)$.
%\item
%Определяют новый вектор неизвестных 
%в соответствии с соотношением \eqref{eq:GD:x(k+1)}:
%\begin{gather*}
%\left\{\begin{matrix}
%x_1&=&x_0 - \lambda\cdot{\nabla_0}_x\\
%y_1&=&y_0 - \lambda\cdot{\nabla_0}_y\\
%\end{matrix}\right.,
%\end{gather*}
%где ${\nabla_0}_x$ и ${\nabla_0}_y$ --
%компоненты вектора градиента в выбранной системе координат.
%\item
%Рассчитывают величину расстояния между двумя точками:
%\begin{gather*}
%r=\sqrt{(x_0-x_1)^2+(y_0-y_1)^2}
%\end{gather*}
%\item
%Проверяют условие остановки итерационного процесса:
%если $r<\varepsilon$, то итерационный процесс останавливается;
%иначе текущую точку считают начальной 
%$x_0=x_1$ и $y_0=y_1$ и переходят к шагу (2) 
%итерационного процесса.
%\end{enumerate}


% *** Алгоритм поиска минимума функции одной переменной
% https://tex.stackexchange.com/questions/370704/drawing-a-scheme
\begin{figure}[H]\centering
\begin{tikzpicture}[
font=\small,
start chain=going below,node distance=10mm,every join/.style=->,%
>={Straight Barb[angle=45:1.5mm 1]},shorten >=0.5pt,%
]
% соединитель
\node[rrectnode,on chain,join]{старт};
% данные
\node[datanode,on chain,join]
{$\vect{x}_0, \lambda, \varepsilon_1$};
% grad(f)
\node[rectnode,on chain,join](grad0)
{$\nabla_0=\nabla{f(\vect{x}_0})$};
% x1
\node[rectnode,on chain,join](x1)
{$\vect{x}_1=\vect{x}_0-\lambda\cdot\nabla_0$};
% сравнение
\node[ifthenelsenode,on chain,join](compare)
{$\norma{\vect{x}_1-\vect{x}_0}\leqslant\varepsilon_1$};
% нет
\begin{scope}[start branch=b,node distance=15mm]
\node[rectnode,on chain=going right,join](no)
{$\vect{x}_0=\vect{x}_1$};
\draw(compare.east) node[above right]{нет};
\draw[->,thick] (no.north) |- (grad0.east);
\end{scope}
% выход
\draw (compare.south) node[below left]{да};
\begin{scope}[node distance=12mm]
\node[rrectnode,on chain,join]{стоп};
\end{scope}
\end{tikzpicture}
% *******************************************
\caption{Блок-схема алгоритма нахождения минимума\linebreak 
функции $f(\vect{x})$ многих переменных 
методом градиентного спуска}
\label{fig:GD:scheme gradf(x)->min}
\end{figure}


% Метод тяжелого шара
\emptyline
\subsubsection{Метод тяжелого шара}
Поиск минимума функции многих переменных $f(\vect{x})$
методом ``тяжелого шара`` основан на аналогии 
движения материальной частицы массой $m$ 
в консервативном силовом поле $\vect{F}(\vect{x})$
в вязкой среде.

В соответствии с принципом минимальной энергии
тело смещается в положение, которое минимизирует общую 
потенциальную энергию системы\linebreak
$f(\vect{x})\to\min$.
Поэтому если предположить, что функция $f(\vect{x})$ 
является потенциальной энергией частицы 
в консервативном силовом поле 
$\vect{F}(\vect{x})=-\nabla{f(\vect{x})}$,
и частица перемещается в пространстве $\vect{x}$ 
минимизируя свою энергию, то уравнение движения 
этой частицы можно записать в виде:
\begin{equation}
\left\{
\begin{matrix}[rcl]
\diff{\vect{x}}{t}&=&\vect{v}\\[1em]
m\,\diff{\vect{v}}{t}&=&\vect{F} - \alpha\cdot\vect{v}
\end{matrix}
\right.
\end{equation}
где 
$\vect{x}$ -- положение частицы в выбранной системе координат;
$\vect{v}$ и $\alpha$ -- 
скорость и коэффициент вязкого трения частицы в среде,
соответственно.

Этот метод используется в методе стохастического градиентного спуска 
и в качестве расширения алгоритмов обратного распространения ошибок
для обучения искусственных нейронных сетей.

Поиск минимума данным методом начинается 
с задания начальных условий, которые, как правило,
формулируются в виде:
\begin{equation}
\begin{cases}
\vect{x}(0)=&\vect{x}_0\\
\vect{v}(0)=&\vect{v}_0\\
\end{cases},
\end{equation}
где $\vect{x}_0$ -- начальное приближения для поиска
минимума функции;
$\vect{v}_0$ -- ``начальная скорость`` в пространстве неизвестных.

Масса частицы $m$ и коэффициент вязкого трения $\alpha$
являются эвристическими параметрами метода и выбираются
произвольным образом, отражающим специфику решаемой задачи.

%
%	Пример
%
\emptyline
\subsection{Поиск оптимального положения склада}
Рассмотрим задачу нахождения координат 
расположения склада готовой продукции, таких чтобы 
суммарное расстояние от склада до потребителей продукции
было минимальным. 

Известны местоположение трех городов торговой сети 
\emph{в декартовой системе координат}: 
\href{https://ru.wikipedia.org/wiki/\%D0\%9D\%D0\%B8\%D0\%BF\%D0\%BF\%D1\%83\%D1\%80}{Ниппур} $(4,2)$,
\href{https://ru.wikipedia.org/wiki/\%D0\%AD\%D1\%80\%D0\%B8\%D0\%B4\%D1\%83}{Эриду} $(1,7)$
\href{https://ru.wikipedia.org/wiki/\%D0\%A8\%D1\%83\%D1\%80\%D1\%83\%D0\%BF\%D0\%BF\%D0\%B0\%D0\%BA}{Шуруппак} $(8,4)$.
% *******************************
%	График функций
%
\begin{figure}[H]\centering
\begin{tikzpicture}
\begin{axis}[
	enlargelimits=true,
	xlabel = {широта ($x$)},	% подпись оси x
	ylabel = {долгота ($y$)},	% подпись оси y
	xmin=0,ymin=0,xmax=10,ymax=10,
]
% Склад
\addplot[ball darkred] coordinates {(5,9)} coordinate (wh)
node[above right]{склад $(x_0,y_0)$};
% города
\addplot[ball darkblue] coordinates {(4,2)} coordinate (c1)
node[below]{Ниппур};
\addplot[ball darkblue] coordinates {(1,7)} coordinate (c2)
node[below]{Эриду};
\addplot[ball darkblue] coordinates {(8,4)} coordinate (c3)
node[below]{Шуруппак};
% расстояние
\begin{scope}[color=darkblue]
\draw (wh) -- (c1) node [sloped,midway,above] {$r_1$};
\draw (wh) -- (c2) node [sloped,midway,above] {$r_2$};
\draw (wh) -- (c3) node [sloped,midway,above] {$r_3$};
\end{scope}
\end{axis}
\end{tikzpicture}
\end{figure}
% *******************************

\begin{enumerate}
\item
Обозначим неизвестные:\\
$x$ и $y$ -- положения склада по горизонтальной
и вертикальной оси координат, соответственно.
\item
Целевая функция -- суммарное расстояние от склада до всех магазинов:
\begin{gather*}
f=r_1 + r_2 + r_3,
\end{gather*}
где $r_1$, $r_2$ и $r_3$ -- расстояние от \alert{склада}
до городов {Ниппур}, {Эриду} и {Шуруппак}, соответственно.
\item
В выбранной декартовой системе координат и 
для нахождения расстояния от склада до каждого 
города воспользуемся теоремой 
\href{https://ru.wikipedia.org/wiki/\%D0\%9F\%D0\%B8\%D1\%84\%D0\%B0\%D0\%B3\%D0\%BE\%D1\%80}{Пифагора Самосского}:
\begin{gather*}
r_1=\sqrt{(x_1-x)^2+(y_1-y)^2}\\
r_2=\sqrt{(x_2-x)^2+(y_2-y)^2}\\
r_3=\sqrt{(x_3-x)^2+(y_3-y)^2},
\end{gather*}
где 
$x_1$ и $y_1$ -- декартовы координаты города Ниппур;
$x_2$ и $y_2$ -- декартовы координаты города Эриду;
$x_3$ и $y_3$ -- декартовы координаты города Шуруппак.

Таким образом, целевая функция -- суммарное расстояние 
от склада до всех городов, с учетом данных задания 
о координатах городов (Ниппур, Эриду и Шуруппак),
запишется в виде:
\begin{gather*}
\begin{split}
f(x,y)=
&\sqrt{(4-x)^2+(2-y)^2}\;+\\
&\sqrt{(1-x)^2+(7-y)^2}\;+\\
&\sqrt{(8-x)^2+(4-y)^2}
\end{split}
\end{gather*}

\item
Определим градиент целевой функции $\nabla{f(x,y)}$:
\begin{gather*}
\nabla{f(x,y)}=\left(\pdiff{f}{x},\,\pdiff{f}{y}\right)
\end{gather*}
Для этого найдем частные производные целевой функции 
от координат $x$ и $y$ положения склада:
\begin{gather*}
\begin{split}
\pdiff{f}{x}=
-&\dfrac{4-x}{\sqrt{(4-x)^2+(2-y)^2}}\\
-&\dfrac{1-x}{\sqrt{(1-x)^2+(7-y)^2}}\\
-&\dfrac{8-x}{\sqrt{(8-x)^2+(4-y)^2}}\\
\end{split}
\end{gather*}

\begin{gather*}
\begin{split}
\pdiff{f}{y}=
-&\dfrac{2-y}{\sqrt{(4-x)^2+(2-y)^2}}\\
-&\dfrac{7-y}{\sqrt{(1-x)^2+(7-y)^2}}\\
-&\dfrac{4-y}{\sqrt{(8-x)^2+(4-y)^2}}\\
\end{split}
\end{gather*}

\item
Выбираем (в общем случае, произвольно)
начальные координаты склада, например, $x_0=5$ и $y_0=9$,
скорость градиентного спуска $\lambda=2$ и
точность расчёта $\varepsilon_1=0.25$ (единиц измерения).

\item
Текущее суммарное расстояние от склада до всех городов:
\begin{gather*}
\begin{split}
R_0=f(5,9)=
&\sqrt{(4-5)^2+(2-9)^2}\\
+&\sqrt{(1-5)^2+(7-9)^2}\\
+&\sqrt{(8-5)^2+(4-9)^2}=17.37
\end{split}
\end{gather*}

Определим градиент целевой функции в начальной точке 
положения склада $(x_0,y_0)$:
\begin{gather*}
\begin{split}
\left.\pdiff{f}{x}\right\rvert_{
\begin{smallmatrix}x&=&5\\y&=&9\end{smallmatrix}
}=
-&\dfrac{4-5}{\sqrt{(4-5)^2+(2-9)^2}}\\
-&\dfrac{1-5}{\sqrt{(1-5)^2+(7-9)^2}}\\
-&\dfrac{8-5}{\sqrt{(8-5)^2+(4-9)^2}}=0.52
\end{split}
\end{gather*}
\begin{gather*}
\begin{split}
\left.\pdiff{f}{y}\right\rvert_{
\begin{smallmatrix}x&=&5\\y&=&9\end{smallmatrix}
}=
-&\dfrac{2-9}{\sqrt{(4-5)^2+(2-9)^2}}\\
-&\dfrac{7-9}{\sqrt{(1-5)^2+(7-9)^2}}\\
-&\dfrac{4-9}{\sqrt{(8-5)^2+(4-9)^2}}=2.29
\end{split}
\end{gather*}

Зная градиент целевой функции в начальной точке 
$\nabla f(x_0,y_0)=(0.52, 2.29)$,
определим новые координаты склада:
\begin{gather*}
x_1=x_0 - \lambda\cdot
\left.\pdiff{f}{x}\right\rvert_{
\begin{smallmatrix}x=5\\y=9\end{smallmatrix}
}=5-2\cdot0.52=3.96\\
y_1=y_0 - \lambda\cdot
\left.\pdiff{f}{y}\right\rvert_{
\begin{smallmatrix}x=5\\y=9\end{smallmatrix}
}
=9-2\cdot2.29=4.41
\end{gather*}

\emph{Новые координаты склада} 
$(x_1=3.96; y_1=4.41)$.
% *******************************
%	График функций
%
\begin{figure}[H]\centering
\begin{tikzpicture}[% стрелка
>={Straight Barb[angle=45:2mm 1]},shorten >=2.5pt,
]
\begin{axis}[
	enlargelimits=true,
	xlabel = {широта ($x$)},	% подпись оси x
	ylabel = {долгота ($y$)},	% подпись оси y
	xmin = 0, ymin = 0,
	xmax = 10, ymax = 10,	
]
\addplot[->,ball darkred] coordinates {(5,9) (3.96,4.41)} coordinate (wh)
node[left]{склад};
\draw[darkred] (axis cs: 5,9) node[above]{$(x_0,y_0)$};
% города
\addplot[ball darkblue] coordinates {(4,2)} coordinate (c1)
node[below]{Ниппур};
\addplot[ball darkblue] coordinates {(1,7)} coordinate (c2)
node[above]{Эриду};
\addplot[ball darkblue] coordinates {(8,4)} coordinate (c3)
node[below]{Шуруппак};
\end{axis}
\end{tikzpicture}
\end{figure}
% *******************************

Рассчитаем величину ``шага`` -- расстояния между двумя 
последовательными положениями склада:
\begin{gather*}
r=\sqrt{(5-3,96)^2+(9-4,41)^2}=4,71
\end{gather*}

Сравниваем величину текущего ``шага`` $r$ и 
заданную точность расчетов $\varepsilon_1$:
\begin{gather*}
r=4.71>0.25=\varepsilon_1
\end{gather*}
Величина текущего ``шага`` $r$ больше заданной 
точности расчетов $\varepsilon_1$,
следовательно, \emph{итерационный процесс продолжаем}!

\item
Текущее суммарное расстояние от склада до всех городов:
\begin{gather*}
\begin{split}
R_1=f(3.96,4.41)=
&\sqrt{(4-3.96)^2+(2-4.41)^2}\\
+&\sqrt{(1-3.96)^2+(7-4.41)^2}\\
+&\sqrt{(8-3.96)^2+(4-4.41)^2}=10.41
\end{split}
\end{gather*}

Суммарное расстояние уменьшилось:
\begin{equation*}
R_1=10.41<17.37=R_0.
\end{equation*}

Рассчитаем градиент целевой функции в новой точке 
положения склада\linebreak $x_1=3.96$ и $y_1=4.41$:
\begin{gather*}
\begin{split}
\left.\pdiff{f}{x}\right\rvert_{
\begin{smallmatrix}x_1&=&3.96\\y_1&=&4.41\end{smallmatrix}
}=
-&\dfrac{4-3.96}{\sqrt{(4-3.96)^2+(2-4.41)^2}}\\
-&\dfrac{1-3.96}{\sqrt{(1-3.96)^2+(7-4.41)^2}}\\
-&\dfrac{8-3.96}{\sqrt{(8-3.96)^2+(4-4.41)^2}}=-0.26\\
\end{split}
\end{gather*}
\begin{gather*}
\begin{split}
\left.\pdiff{f}{y}\right\rvert_{
\begin{smallmatrix}x_1&=&3.96\\y_1&=&4.41\end{smallmatrix}
}=
-&\dfrac{2-4.41}{\sqrt{(4-3.96)^2+(2-4.41)^2}}\\
-&\dfrac{7-4.41}{\sqrt{(1-3.96)^2+(7-4.41)^2}}\\
-&\dfrac{4-4.41}{\sqrt{(8-3.96)^2+(4-4.41)^2}}=0.44
\end{split}
\end{gather*}

Зная градиент целевой функции в текущей точке 
$\nabla f(x_1,y_1)=(-0.26,0.44)$,
определим новые координаты склада:
\begin{gather*}
x_2=x_1 - \lambda\cdot
\left.\pdiff{f}{x}\right\rvert_{
\begin{smallmatrix}x=3.96\\y=4.41\end{smallmatrix}
}=
3.96-2\cdot(-0.26)=4.48\\
y_2=y_1 - \lambda\cdot
\left.\pdiff{f}{y}\right\rvert_{
\begin{smallmatrix}x=3.96\\y=4.41\end{smallmatrix}
}=
4.41-2\cdot0.44=3.53\\
\end{gather*}

\emph{Новые координаты склада} 
$(x_2=4.48, y_2=3.53)$.
% *******************************
%	График функций
%
\begin{figure}[H]\centering
\begin{tikzpicture}[% стрелка
>={Straight Barb[angle=45:2mm 1]},shorten >=2.5pt,
]
\begin{axis}[
	enlargelimits=true,
	xlabel = {широта ($x$)},	% подпись оси x
	ylabel = {долгота ($y$)},	% подпись оси y
	xmin = 0, ymin = 0,
	xmax = 10, ymax = 10,	
]
% Склад
\addplot[->,ball darkred] coordinates {(5,9) (3.96,4.41) (4.48,3.53)};
\draw[darkred] (axis cs: 5,9) node[above]{$(x_0,y_0)$};
\draw[darkred] (axis cs: 3.96,4.41) node[left]{$(x_1,y_1)$};
\draw[darkred] (axis cs: 4.48,3.53) node[below right]{склад};
% города
\addplot[ball darkblue] coordinates {(4,2)}
node[below]{Ниппур};
\addplot[ball darkblue] coordinates {(1,7)}
node[above]{Эриду};
\addplot[ball darkblue] coordinates {(8,4)}
node[above]{Шуруппак};
\end{axis}
\end{tikzpicture}
\end{figure}
% *******************************

Рассчитаем величину ``шага`` -- расстояния между 
двумя последовательными положениями склада:
\begin{gather*}
r=\sqrt{(3.96-4.48)^2+(4.41-3.53)^2}=1.03
\end{gather*}

Сравниваем величину текущего ``шага`` $r$ и 
заданную точность расчетов $\varepsilon_1$:
\begin{gather*}
r=1.03>0.25=\varepsilon
\end{gather*}
Величина текущего ``шага`` $r$ больше заданной точности 
расчетов $\varepsilon_1$, следовательно, 
\emph{итерационный процесс продолжаем}!

\item
Текущее суммарное расстояние от склада до всех городов:
\begin{gather*}
\begin{split}
R_2=f(4.48,3.53)=
&\sqrt{(4-4.48)^2+(2-3.53)^2}\\
+&\sqrt{(1-4.48)^2+(7-3.53)^2}\\
+&\sqrt{(8-4.48)^2+(4-3.53)^2}=10.07
\end{split}
\end{gather*}

Рассчитаем градиент целевой функции в новой точке 
положения склада\linebreak $x_2=4.48$ и $y_2=3.53$:
\begin{gather*}
\begin{split}
\left.\pdiff{f}{x}\right\rvert_{
\begin{smallmatrix}x_2&=&4.48\\y_2&=&3.53\end{smallmatrix}
}=
-&\dfrac{4-4.48}{\sqrt{(4-4.48)^2+(2-3.53)^2}}\\
-&\dfrac{1-4.48}{\sqrt{(1-4.48)^2+(7-3.53)^2}}\\
-&\dfrac{8-4.48}{\sqrt{(8-4.48)^2+(4-3.53)^2}}=0.02
\end{split}
\end{gather*}
\begin{gather*}
\begin{split}
\left.\pdiff{f}{y}\right\rvert_{
\begin{smallmatrix}x_2&=&4.48\\y_2&=&3.53\end{smallmatrix}
}=
-&\dfrac{2-3.53}{\sqrt{(4-4.48)^2+(2-3.53)^2}}\\
-&\dfrac{7-3.53}{\sqrt{(1-4.48)^2+(7-3.53)^2}}\\
-&\dfrac{4-3.53}{\sqrt{(8-4.48)^2+(4-3.53)^2}}=0.11
\end{split}
\end{gather*}

Зная градиент целевой функции в текущей точке 
$\nabla f(x_2,y_2)=(0.02,0.11)$,
определяют новое географическое положение склада:
\begin{gather*}
x_3=x_2 - \lambda\cdot
\left.\pdiff{f}{x}\right\rvert_{
\begin{smallmatrix}x=4.48\\y=3.53\end{smallmatrix}
}=4.48-2\cdot0.02=4.45\\
y_3=y_2 - \lambda\cdot
\left.\pdiff{f}{y}\right\rvert_{
\begin{smallmatrix}x=4.48\\y=3.53\end{smallmatrix}
}=3.53-2\cdot0.11=3.30\\
\end{gather*}

\emph{Новые координаты склада} 
$(x_0=4.45, y_0=3.30)$.
% *******************************
%	График функций
%
\begin{center}
\begin{tikzpicture}[% стрелка
>={Straight Barb[angle=45:2mm 1]},shorten >=2.5pt,
]
\begin{axis}[
	enlargelimits=true,
	xlabel = {широта ($x$)},	% подпись оси x
	ylabel = {долгота ($y$)},	% подпись оси y
	xmin = 0, ymin = 0,
	xmax = 10, ymax = 10,	
]
% склад
\addplot[ball darkred] coordinates {(5,9) (3.96,4.41) (4.48,3.53) (4.45,3.30)};
\draw[darkred] (axis cs: 5,9) node[above]{$(x_0,y_0)$};
\draw[darkred] (axis cs: 3.96,4.41) node[left]{$(x_1,y_1)$};
\draw[darkred] (axis cs: 4.48,3.53) node[right]{$(x_2,y_2)$};
\draw[darkred] (axis cs: 4.45,3.30) node[below]{склад};
% города
\addplot[ball darkblue] coordinates {(4,2)}
node[below]{Ниппур};
\addplot[ball darkblue] coordinates {(1,7)}
node[above]{Эриду};
\addplot[ball darkblue] coordinates {(8,4)}
node[above]{Шуруппак};
\end{axis}
\end{tikzpicture}
\end{center}
% *******************************


Рассчитаем величину ``шага`` -- расстояния между 
двумя последовательными положениями склада:
\begin{gather*}
r=\sqrt{(4.48-4.45)^2+(3.53-3.30)^2}=0.23
\end{gather*}

Сравниваем величину текущего ``шага`` $r$ и заданную точность расчетов $\varepsilon$:
\begin{gather*}
r=0.23<0.25=\varepsilon
\end{gather*}
Величина текущего ``шага`` $r$ меньше заданной 
точности расчетов $\varepsilon_1$,
поэтому итерационный процесс поиска положения склада 
\emph{останавливаем}.

\item
Определим минимальное расстояние от склада до всех городов:
\begin{gather*}
\begin{split}
R_4=f(4.45,3.30)=
&\sqrt{(4-4.45)^2+(2-3.30)^2}\\
+&\sqrt{(1-4.45)^2+(7-3.30)^2}\\
+&\sqrt{(8-4.45)^2+(4-3.30)^2}=10.05
\end{split}
\end{gather*}
\end{enumerate}

Таким образом, с заданной точностью определены оптимальные 
координаты склада $(x_{opt}=4.45, y_{opt}=3.30)$, 
при которых общее расстояние от всех городов до склада 
будет минимальным и составит $R_{\min}=10.05$:

\end{document}
